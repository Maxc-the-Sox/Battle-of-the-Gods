<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Battle of the Gods - Master Version A (Tundra Safe)</title>
    <style>
        body { margin: 0; background: #0a0a0a; color: #ddd; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; cursor: grab; background: #1a2a35; }
        #setup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000 url('https://github.com/Maxc-the-Sox/Battle-of-the-Gods/blob/main/Batte%20of%20the%20Gods%201.jpg?raw=true') no-repeat center center; background-size: cover; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .menu-box { background: rgba(0, 0, 0, 0.95); padding: 30px; border-radius: 15px; border: 2px solid #d4af37; text-align: center; box-shadow: 0 0 50px rgba(0,0,0,0.9); width: 400px; }
        h1 { color: #d4af37; text-transform: uppercase; letter-spacing: 4px; margin-bottom: 10px; font-size: 2em; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: left; margin-top: 20px; font-size: 0.85em; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 8px; }
        .settings-grid input { background: #222; border: 1px solid #d4af37; color: #fff; padding: 5px; border-radius: 4px; width: 60px; text-align: center; }
        .menu-btn { width: 100%; padding: 15px 0; font-size: 1.2em; font-weight: bold; border-radius: 5px; cursor: pointer; display: block; text-align: center; margin-top: 20px; text-transform: uppercase; transition: transform 0.2s; }
        .btn-start { background: linear-gradient(to bottom, #d4af37, #aa8928); color: #000; border: none; }
        select { padding: 12px; width: 100%; background: #222; color: #fff; border: 1px solid #d4af37; border-radius: 5px; font-size: 1.1em; }
        #ui-panel { position: absolute; top: 20px; left: 20px; background: rgba(20, 20, 20, 0.95); padding: 20px; border-radius: 8px; border: 1px solid #d4af37; width: 280px; z-index: 10; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        .player-header { padding: 10px; border-radius: 4px; margin-bottom: 5px; font-weight: bold; text-align: center; background: rgba(255,255,255,0.05); color: #d4af37; border: 2px solid transparent; }
        #artifact-display { text-align: center; background: rgba(0, 0, 0, 0.4); border: 1px solid #f1c40f; color: #f1c40f; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-weight: bold; font-size: 1.1em; }
        .btn { background: #50e3c2; color: #000; border: none; padding: 10px; border-radius: 4px; font-weight: bold; cursor: pointer; width: 100%; margin-top: 8px; transition: background 0.2s; }
        .btn:disabled { background: #444; color: #888; cursor: not-allowed; border: 1px solid #555; }
        .btn-danger { background: #e74c3c !important; color: white !important; }
        .hidden { display: none !important; }
        .card-preview { background: rgba(0,0,0,0.3); border: 1px solid #555; padding: 15px; border-radius: 8px; text-align: center; margin: 10px 0; border-left: 5px solid #d4af37; }
        #dice-display { font-size: 4em; font-weight: bold; color: #f1c40f; margin: 10px 0; display: flex; align-items: center; justify-content: center; }
        #dice-display.rolling { animation: shake 0.3s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, 2px); } 100% { transform: translate(1px, -2px); } }
        #hover-info { margin-top: 20px; border-top: 1px solid #555; padding-top: 10px; font-size: 0.85em; color: #aaa; }
    </style>
</head>
<body>

<div id="setup-overlay">
    <div class="menu-box">
        <h1>BATTLE OF THE GODS</h1>
        <select id="player-count" onchange="updateDefaultSettings()">
            <option value="2">2 Spieler</option>
            <option value="3">3 Spieler</option>
            <option value="4">4 Spieler</option>
            <option value="5">5 Spieler</option>
            <option value="6">6 Spieler</option>
        </select>
        <div class="settings-grid">
            <label>Ziel Artefakte:</label><input type="number" id="cfg-target" value="6">
            <label>Ring 1 (Au√üen):</label><input type="number" id="cfg-ring1" value="2">
            <label>Ring 2 (Mitte):</label><input type="number" id="cfg-ring2" value="4">
            <label>Ring 3 (Innen):</label><input type="number" id="cfg-ring3" value="6">
        </div>
        <button class="menu-btn btn-start" onclick="loadStandardMap()">SPIEL STARTEN</button>
    </div>
</div>

<div id="ui-panel" class="hidden">
    <div id="artifact-display">üèÜ Artefakte: 0 / ?</div>
    <div id="player-turn-display" class="player-header">Spieler X</div>
    <div id="status-text" style="font-size:0.8em; color:#d4af37; margin-bottom:10px; text-align:center; font-weight:bold;">AKTION W√ÑHLEN</div>
    <div id="action-controls">
        <div id="choice-area">
            <button id="btn-choice-draw" class="btn" onclick="handleChoice('DRAWING')">2x Karte ziehen</button>
            <button id="btn-choice-move" class="btn" onclick="handleChoice('MOVING')">2x Bewegen</button>
        </div>
        <div id="drawing-area" class="hidden">
            <button id="btn-draw-card" class="btn" onclick="drawCard()">Karte ziehen (<span id="cards-left">2</span>)</button>
            <div id="active-card" class="hidden">
                <div class="card-preview"><span id="card-icon" style="font-size: 2.5em; display: block;"></span><span id="card-name" style="font-weight: bold; text-transform: uppercase;"></span></div>
                <div id="dice-section"><div id="dice-display"><span id="dice-symbol">?</span></div><button id="btn-roll-dice" class="btn" style="background:#f1c40f" onclick="rollDice()">W√úRFELN</button></div>
                <p id="placement-info" style="font-size: 0.85em; color: #f1c40f; text-align:center; font-weight:bold;"></p>
            </div>
            <div id="rotation-controls" class="hidden"><button class="btn" onclick="rotateRiver()">Drehen ‚Üª</button><button class="btn" style="background:#2ecc71; color:white;" onclick="confirmRiver()">Setzen ‚úì</button></div>
            <button id="btn-finish-drawing" class="btn btn-danger" onclick="finishDrawingPhase()">Ziehen beenden</button>
        </div>
        <div id="movement-area" class="hidden"><p id="ap-display" style="text-align:center; font-weight:bold; color:#50e3c2; margin-bottom:5px;"></p><button class="btn btn-danger" onclick="finishPath()">Bewegung beenden</button></div>
    </div>
    <div id="hover-info" style="display: none;"><div id="hover-terrain" style="color: #fff; font-weight: bold;"></div><div id="hover-extra" style="color: #f1c40f; font-weight: bold;"></div></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let mapData = { hexes: {}, landmarks: [] };
let hexSize = 40, camera = { x: 0, y: 0, zoom: 0.8 }, iconCache = {};
let players = [], currentPlayerIdx = 0, gameState = "SETUP";
let drawPoints = 2, actionPoints = 2, collectedArtifacts = 0;
let targetArtifacts = 6, ringThresholds = [2, 4, 6], closedRings = { outer: false, middle: false, inner: false };
let pathDrawn = false, pathMoved = false, isDragging = false, lastMouse = { x: 0, y: 0 };
let currentCard = null, diceValue = 0, placementsRemaining = 0, pendingRiverHex = null, selectedUnit = null, riverEscapeHexes = [];

const terrainColors = { water: '#4fa3e0', river: '#81ecec', desert: '#d4bb7e', swamp: '#3d4a3d', plains: '#5a8d46', forest: '#1b4d3e', mountains: '#4d4d4d', road: '#333333', hills: '#7f8c8d', tundra: '#b2bec3', void: '#000' };
const terrainNames = { water: 'Wasser', river: 'Fluss', desert: 'W√ºste', swamp: 'STARTBURG', plains: 'Ebene', forest: 'Wald', mountains: 'Gebirge', road: 'STRASSE', hills: 'H√ºgel', tundra: 'Tundra', void: 'VERNICHTET' };
const hexDirections = [{q:1,r:0}, {q:0,r:1}, {q:-1,r:1}, {q:-1,r:0}, {q:0,r:-1}, {q:1,r:-1}];

function updateDefaultSettings() {
    const count = parseInt(document.getElementById('player-count').value);
    const target = (count == 2) ? 6 : (count <= 4 ? 7 : 8);
    const rings = (count == 2) ? [2, 4, 6] : (count <= 4 ? [3, 5, 7] : [4, 6, 8]);
    document.getElementById('cfg-target').value = target;
    document.getElementById('cfg-ring1').value = rings[0];
    document.getElementById('cfg-ring2').value = rings[1];
    document.getElementById('cfg-ring3').value = rings[2];
}

async function loadStandardMap() {
    try {
        const response = await fetch('https://raw.githubusercontent.com/Maxc-the-Sox/Battle-of-the-Gods/refs/heads/main/Battle%20of%20the%20Gods.json');
        const data = await response.json();
        targetArtifacts = parseInt(document.getElementById('cfg-target').value);
        ringThresholds = [parseInt(document.getElementById('cfg-ring1').value), parseInt(document.getElementById('cfg-ring2').value), parseInt(document.getElementById('cfg-ring3').value)];
        processLoadedMap(data, parseInt(document.getElementById('player-count').value));
    } catch (e) { alert("Ladefehler."); }
}

function processLoadedMap(data, count) {
    mapData = data;
    Object.values(mapData.hexes).forEach(h => h.baseTerrain = h.terrain);
    mapData.landmarks.forEach(lm => { if(lm.icon && !iconCache[lm.icon]) { const img = new Image(); img.src = lm.icon; img.onload = () => render(); iconCache[lm.icon] = img; } });
    players = Array.from({length: count}, (_, i) => ({ id: i+1, color: ["#ff4757", "#2e86de", "#2ecc71", "#f1c40f", "#9b59b6", "#e67e22"][i], units: [] }));
    document.getElementById('setup-overlay').style.display = 'none';
    document.getElementById('ui-panel').classList.remove('hidden');
    gameState = "PLACING"; centerMap(); updateUI(); render();
}

function triggerKollaps(baseTerrains, key) {
    closedRings[key] = true;
    Object.values(mapData.hexes).forEach(hex => {
        // TUNDRA WIRD HIER EXPLIZIT √úBERSPRUNGEN
        if (baseTerrains.includes(hex.baseTerrain) && hex.baseTerrain !== 'water' && hex.baseTerrain !== 'tundra') {
            hex.terrain = 'void';
            players.forEach(p => p.units = p.units.filter(u => !(u.q === hex.q && u.r === hex.r)));
        }
    });
    alert(`RING-KOLLAPS!`);
    render();
}

function checkApocalypse() {
    if (collectedArtifacts >= ringThresholds[0] && !closedRings.outer) triggerKollaps(['desert', 'swamp'], 'outer');
    if (collectedArtifacts >= ringThresholds[1] && !closedRings.middle) triggerKollaps(['plains'], 'middle');
    if (collectedArtifacts >= ringThresholds[2] && !closedRings.inner) triggerKollaps(['hills'], 'inner');
}

function handleChoice(choice) { if (choice === 'DRAWING') { drawPoints = 2; gameState = "DRAWING"; } else if (choice === 'MOVING') { actionPoints = 2; gameState = "MOVING"; } updateUI(); render(); }
function drawCard() { currentCard = [{name:"Berg",type:"mountains",icon:"‚õ∞Ô∏è"},{name:"Wald",type:"forest",icon:"üå≤"},{name:"Fluss",type:"river",icon:"üåä"},{name:"Stra√üe",type:"road",icon:"üõ§Ô∏è"}][Math.floor(Math.random()*4)]; diceValue = 0; document.getElementById('dice-symbol').innerText = "?"; gameState = "DICE_ROLL"; updateUI(); }
function rollDice() {
    const diceDisplay = document.getElementById('dice-display');
    diceDisplay.classList.add('rolling');
    setTimeout(() => {
        diceValue = [3, 2, 2, 1, 1, 1][Math.floor(Math.random() * 6)];
        placementsRemaining = diceValue;
        document.getElementById('dice-symbol').innerText = ['','‚öÄ','‚öÅ','‚öÇ'][diceValue] || diceValue;
        diceDisplay.classList.remove('rolling');
        gameState = "PLACING_TERRAIN"; updateUI();
    }, 500);
}

function processMovement(unit, tQ, tR) {
    const oldHex = mapData.hexes[`${unit.q},${unit.r}`];
    const newHex = mapData.hexes[`${tQ},${tR}`];
    if (!newHex || newHex.terrain === 'mountains' || newHex.terrain === 'void') return false;
    let cost = (newHex.terrain === 'road' && oldHex.terrain !== 'road') ? 0 : 1;
    unit.q = tQ; unit.r = tR; checkLandmark(tQ, tR);
    if (newHex.terrain === 'river') {
        let curH = newHex;
        while (true) {
            let nQ = unit.q + hexDirections[curH.direction || 0].q, nR = unit.r + hexDirections[curH.direction || 0].r, nH = mapData.hexes[`${nQ},${nR}`];
            if (!nH || ['mountains', 'water', 'void'].includes(nH.terrain)) {
                riverEscapeHexes = hexDirections.map(d => ({q: unit.q+d.q, r: unit.r+d.r})).filter(p => { const h = mapData.hexes[`${p.q},${p.r}`]; return h && !['mountains', 'water', 'void', 'river'].includes(h.terrain); });
                if (riverEscapeHexes.length > 0) { gameState = "RIVER_ESCAPE"; updateUI(); return true; } else { actionPoints = 0; finishPath(); return true; }
            } else if (nH.terrain === 'river') { unit.q = nQ; unit.r = nR; checkLandmark(nQ, nR); curH = nH; } else { unit.q = nQ; unit.r = nR; checkLandmark(nQ, nR); actionPoints = 0; finishPath(); return true; }
        }
    } else { actionPoints -= cost; if (newHex.terrain === 'forest') actionPoints = 0; if (actionPoints <= 0) finishPath(); }
    updateUI(); render();
}

function startTurn() { pathDrawn = false; pathMoved = false; gameState = "CHOOSING"; updateUI(); render(); }
function finishDrawingPhase() { pathDrawn = true; checkTurnEnd(); }
function finishPath() { actionPoints = 0; pathMoved = true; selectedUnit = null; checkTurnEnd(); }
function checkTurnEnd() { if (pathDrawn && pathMoved) { currentPlayerIdx = (currentPlayerIdx + 1) % players.length; startTurn(); } else { gameState = "CHOOSING"; updateUI(); render(); } }
function rotateRiver() { if (pendingRiverHex) { pendingRiverHex.direction = (pendingRiverHex.direction + 1) % 6; render(); } }
function confirmRiver() { pendingRiverHex = null; placementsRemaining--; if (placementsRemaining <= 0) finishCard(); else gameState = "PLACING_TERRAIN"; updateUI(); render(); }
function finishCard() { drawPoints--; currentCard = null; if (drawPoints <= 0) finishDrawingPhase(); else gameState = "DRAWING"; updateUI(); render(); }

canvas.addEventListener('click', e => {
    const x = (e.clientX-camera.x)/(hexSize*camera.zoom), y = (e.clientY-camera.y)/(hexSize*camera.zoom), q = (2/3*x), r = (-1/3*x + Math.sqrt(3)/3*y);
    let rx = Math.round(q), rz = Math.round(r), ry = Math.round(-q-r);
    if (Math.abs(rx-q)>Math.abs(ry-(-q-r)) && Math.abs(rx-q)>Math.abs(rz-r)) rx = -ry-rz; else if (Math.abs(ry-(-q-r)) > Math.abs(rz-r)) ry = -rx-rz; else rz = -rx-ry;
    if (gameState === "RIVER_ESCAPE") { if (riverEscapeHexes.some(h => h.q === rx && h.r === rz)) { selectedUnit.q = rx; selectedUnit.r = rz; checkLandmark(rx, rz); riverEscapeHexes = []; actionPoints = 0; finishPath(); } return; }
    const hex = mapData.hexes[`${rx},${rz}`]; if (!hex || hex.terrain === 'void') return;
    if (gameState === "PLACING" && hex.terrain === 'swamp') { players[currentPlayerIdx].units.push({ q: rx, r: rz }); if (players.every(p => p.units.length === 2)) { currentPlayerIdx = 0; startTurn(); } else currentPlayerIdx = (currentPlayerIdx + 1) % players.length; }
    else if (gameState === "MOVING") { const u = players[currentPlayerIdx].units.find(u => u.q === rx && u.r === rz); if (u) selectedUnit = u; else if (selectedUnit && (Math.abs(selectedUnit.q-rx)+Math.abs(selectedUnit.q+selectedUnit.r-rx-rz)+Math.abs(selectedUnit.r-rz))/2 === 1) processMovement(selectedUnit, rx, rz); }
    else if (gameState === "PLACING_TERRAIN" && currentCard) { hex.terrain = currentCard.type; if (currentCard.type === 'river') { hex.direction = 0; pendingRiverHex = hex; gameState = "ROTATING_RIVER"; } else { placementsRemaining--; if (placementsRemaining <= 0) finishCard(); } }
    updateUI(); render();
});

window.addEventListener('mousemove', e => {
    if (isDragging) { camera.x += (e.clientX-lastMouse.x); camera.y += (e.clientY-lastMouse.y); lastMouse = {x:e.clientX, y:e.clientY}; render(); }
    const x = (e.clientX-camera.x)/(hexSize*camera.zoom), y = (e.clientY-camera.y)/(hexSize*camera.zoom), q = (2/3*x), r = (-1/3*x + Math.sqrt(3)/3*y);
    let rx = Math.round(q), rz = Math.round(r), ry = Math.round(-q-r);
    if (Math.abs(rx-q)>Math.abs(ry-(-q-r)) && Math.abs(rx-q)>Math.abs(rz-r)) rx = -ry-rz; else if (Math.abs(ry-(-q-r))>Math.abs(rz-r)) ry = -rx-rz; else rz = -rx-ry;
    const hex = mapData.hexes[`${rx},${rz}`], hInfo = document.getElementById('hover-info');
    if (hex) {
        hInfo.style.display = 'block'; document.getElementById('hover-terrain').innerText = (terrainNames[hex.terrain] || hex.terrain).toUpperCase();
        const lm = mapData.landmarks.find(l => l.q === rx && l.r === rz);
        let extraText = (lm && !lm.looted) ? "‚ôú RUINE MIT ARTEFAKT" : (lm ? "üï∏Ô∏è LEERE RUINE" : "");
        if (lm && lm.icon && lm.icon.toLowerCase().includes('temple')) extraText = "‚ú® TEMPEL";
        document.getElementById('hover-extra').innerText = extraText;
    } else hInfo.style.display = 'none';
});

function updateUI() {
    const p = players[currentPlayerIdx];
    document.getElementById('player-turn-display').innerText = `Spieler ${p?.id || ''}`;
    document.getElementById('player-turn-display').style.borderColor = p?.color || '#d4af37';
    document.getElementById('artifact-display').innerText = `üèÜ Artefakte: ${collectedArtifacts} / ${targetArtifacts}`;
    document.getElementById('choice-area').classList.toggle('hidden', gameState !== 'CHOOSING');
    document.getElementById('btn-choice-draw').disabled = pathDrawn; document.getElementById('btn-choice-move').disabled = pathMoved;
    const isD = ['DRAWING', 'DICE_ROLL', 'PLACING_TERRAIN', 'ROTATING_RIVER'].includes(gameState);
    document.getElementById('drawing-area').classList.toggle('hidden', !isD);
    document.getElementById('movement-area').classList.toggle('hidden', gameState !== 'MOVING'); 
    document.getElementById('btn-draw-card').classList.toggle('hidden', gameState !== 'DRAWING');
    document.getElementById('active-card').classList.toggle('hidden', !['DICE_ROLL', 'PLACING_TERRAIN', 'ROTATING_RIVER'].includes(gameState)); 
    document.getElementById('btn-roll-dice').classList.toggle('hidden', gameState !== 'DICE_ROLL'); 
    document.getElementById('rotation-controls').classList.toggle('hidden', gameState !== 'ROTATING_RIVER');
    if (currentCard) { document.getElementById('card-icon').innerText = currentCard.icon; document.getElementById('card-name').innerText = currentCard.name; }
    document.getElementById('ap-display').innerText = gameState === "RIVER_ESCAPE" ? "NOT-AUSGANG W√ÑHLEN!" : `Aktionen: ${actionPoints}`;
    document.getElementById('placement-info').innerText = placementsRemaining > 0 ? `Noch ${placementsRemaining} setzen` : "";
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); const s = hexSize * camera.zoom;
    Object.values(mapData.hexes).forEach(hex => {
        const x = (hexSize*1.5*hex.q)*camera.zoom+camera.x, y = (hexSize*Math.sqrt(3)*(hex.r+hex.q/2))*camera.zoom+camera.y;
        const esc = riverEscapeHexes.some(h => h.q === hex.q && h.r === hex.r);
        ctx.beginPath(); for (let i=6; i--;) ctx.lineTo(x + s*Math.cos(Math.PI/3*i), y + s*Math.sin(Math.PI/3*i)); ctx.closePath();
        ctx.fillStyle = esc ? "rgba(255, 255, 255, 0.4)" : (terrainColors[hex.terrain] || '#2f3640'); ctx.fill();
        ctx.strokeStyle = esc ? "white" : "rgba(0,0,0,0.2)"; ctx.lineWidth = esc ? 4 : 1; ctx.stroke();
        if (hex.terrain === 'void') { ctx.font = `${s}px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = "white"; ctx.fillText("‚òÅÔ∏è", x, y); }
        else if (['mountains','forest','swamp','water'].includes(hex.terrain)) { ctx.font = `bold ${hex.terrain === 'swamp' ? s*1.3 : s*0.9}px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = "white"; ctx.fillText({mountains:"‚õ∞Ô∏è",forest:"üå≤",swamp:"üè∞",water:"üåä"}[hex.terrain], x, y); }
        if (hex.terrain === 'river') { ctx.save(); ctx.translate(x, y); ctx.rotate(((hex.direction || 0)*60+30)*Math.PI/180); ctx.font = `bold ${s*1.2}px Arial`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillStyle = "white"; ctx.fillText("‚ûú", s*0.3, 0); ctx.restore(); }
    });
    mapData.landmarks.forEach(lm => { const x = (hexSize*1.5*lm.q)*camera.zoom+camera.x, y = (hexSize*Math.sqrt(3)*(lm.r+lm.q/2))*camera.zoom+camera.y; if (iconCache[lm.icon] && mapData.hexes[`${lm.q},${lm.r}`].terrain !== 'void') { ctx.save(); if (lm.looted) ctx.filter = 'sepia(1) saturate(5) hue-rotate(-50deg)'; ctx.drawImage(iconCache[lm.icon], x-s*0.7, y-s*0.7, s*1.4, s*1.4); ctx.restore(); } });
    players.forEach(p => p.units.forEach(u => { const x = (hexSize*1.5*u.q)*camera.zoom+camera.x, y = (hexSize*Math.sqrt(3)*(u.r+u.q/2))*camera.zoom+camera.y; ctx.beginPath(); ctx.arc(x, y, s*0.45, 0, Math.PI*2); ctx.fillStyle = p.color; ctx.fill(); ctx.strokeStyle = u === selectedUnit ? "white" : "black"; ctx.lineWidth = 2; ctx.stroke(); }));
}

function centerMap() { let sw = Object.values(mapData.hexes).find(h => h.terrain === 'swamp') || Object.values(mapData.hexes)[0]; if (sw) { camera.x = canvas.width/2 - (hexSize*1.5*sw.q)*camera.zoom; camera.y = canvas.height/2 - (hexSize*Math.sqrt(3)*(sw.r+sw.q/2))*camera.zoom; } }
canvas.addEventListener('mousedown', e => { isDragging = true; lastMouse = { x: e.clientX, y: e.clientY }; });
window.addEventListener('mouseup', () => isDragging = false);
window.addEventListener('mousemove', e => { if (isDragging) { camera.x += (e.clientX-lastMouse.x); camera.y += (e.clientY-lastMouse.y); lastMouse = {x:e.clientX, y:e.clientY}; render(); } });
canvas.width = window.innerWidth; canvas.height = window.innerHeight;
</script>
</body>
</html>