<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Battle of the Gods - REPLIT ONLINE</title>
    <script src="/socket.io/socket.io.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700;900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background: #0a0a0a; color: #ddd; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        canvas { display: block; cursor: grab; background: #1a2a35; }
        canvas:active { cursor: grabbing; }
        .hidden { display: none !important; }
        
        #notification-popup {
            position: fixed; top: 15%; left: 50%; transform: translateX(-50%) scale(0.8);
            background: linear-gradient(90deg, rgba(0,0,0,0) 0%, rgba(0,0,0,0.95) 20%, rgba(0,0,0,0.95) 80%, rgba(0,0,0,0) 100%);
            border-top: 2px solid #d4af37; border-bottom: 2px solid #d4af37; padding: 20px 60px;
            color: #fff; font-family: 'Cinzel', serif; font-size: 2em; font-weight: 900; text-transform: uppercase;
            text-shadow: 0 0 15px #d4af37; z-index: 5000; pointer-events: none; opacity: 0; transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        #notification-popup.show { opacity: 1; transform: translateX(-50%) scale(1); }

        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 1000; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #setup-overlay { background: #000 url('https://github.com/Maxc-the-Sox/Battle-of-the-Gods/blob/main/Batte%20of%20the%20Gods%201.jpg?raw=true') no-repeat center center; background-size: cover; }
        #lobby-overlay { background: rgba(0,0,0,0.95); color: #d4af37; display: none; }
        .menu-box { background: linear-gradient(145deg, rgba(10, 10, 10, 0.95), rgba(30, 30, 30, 0.98)); padding: 40px; border-radius: 20px; border: 2px solid #d4af37; text-align: center; box-shadow: 0 0 60px rgba(0,0,0,0.9); width: 500px; backdrop-filter: blur(5px); }
        h1, h2 { font-family: 'Cinzel', serif; font-weight: 900; text-transform: uppercase; margin-bottom: 20px; letter-spacing: 4px; background: linear-gradient(to bottom, #fff5c3 0%, #d4af37 40%, #aa8928 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 2px 0px rgba(0,0,0,1)); }
        
        .menu-btn { flex: 1; padding: 18px 0; font-size: 1.1em; font-family: 'Cinzel', serif; font-weight: bold; border-radius: 8px; cursor: pointer; text-transform: uppercase; width: 100%; margin-top: 10px; }
        .btn-start { background: linear-gradient(to bottom, #d4af37, #8e7220); color: #000; border: 1px solid #f1c40f; }
        .btn-network { background: linear-gradient(to bottom, #3498db, #2980b9); color: #fff; border: 1px solid #5dade2; }
        .btn-secondary { background: #444; color: #ccc; border: 1px solid #555; }
        .settings-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: left; margin-top: 25px; background: rgba(255,255,255,0.03); padding: 20px; border-radius: 10px; border: 1px solid #333; }
        .settings-grid input, select { background: #111; border: 1px solid #555; color: #d4af37; padding: 5px; border-radius: 4px; text-align: center; font-weight: bold; width: 100%; box-sizing: border-box; }
        .button-row { display: flex; gap: 15px; margin-top: 30px; }
        #lobby-player-list { list-style: none; padding: 0; margin: 20px 0; text-align: left; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 10px; }
        #lobby-player-list li { padding: 8px; border-bottom: 1px solid #333; font-weight: bold; }
        
        .dev-credits { font-family: 'Cinzel', serif; font-size: 0.8em; color: #888; margin-top: 25px; text-transform: uppercase; letter-spacing: 1px; border-top: 1px solid #333; padding-top: 10px; }
        .dev-name { color: #d4af37; font-weight: bold; text-shadow: 0 0 5px rgba(212, 175, 55, 0.3); }

        #ui-panel, #inventory-panel, #apo-panel { position: absolute; background: rgba(20, 20, 20, 0.95); padding: 20px; border-radius: 8px; z-index: 10; box-shadow: 0 4px 20px rgba(0,0,0,0.5); display: none; }
        #ui-panel { top: 20px; left: 20px; border: 1px solid #d4af37; width: 280px; }
        #inventory-panel { bottom: 20px; right: 20px; border: 1px solid #3498db; width: 280px; z-index: 20; }
        #apo-panel { bottom: 20px; left: 20px; border: 1px solid #e74c3c; width: 280px; font-size: 0.9em; }
        #victory-panel { position: absolute; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.95); border: 2px solid #f1c40f; padding: 20px; text-align: center; z-index: 2000; border-radius: 8px; width: 280px; display: none; }
        .btn { width: 100%; padding: 10px; margin-top: 8px; cursor: pointer; font-weight: bold; border-radius: 4px; border: none; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; background: #555 !important; }
        .inv-slot { border: 1px dashed #555; padding: 10px; margin-bottom: 5px; display: flex; align-items: center; cursor: pointer; border-radius: 4px; }
        .inv-slot.filled { border: 1px solid #3498db; background: rgba(52, 152, 219, 0.1); }
        .inv-slot.swap-mode { border-color: #e74c3c; animation: pulse-border 1s infinite; }
        .card-preview { background: rgba(0,0,0,0.3); border: 1px solid #555; padding: 15px; border-radius: 8px; text-align: center; margin: 10px 0; border-left: 5px solid #d4af37; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #dice-display { font-size: 4em; color: #f1c40f; text-align: center; display: flex; justify-content: center; align-items: center; min-height: 80px; }
        #dice-display.rolling { animation: shake 0.3s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, 2px); } 100% { transform: translate(1px, -2px); } }
        @keyframes pulse-border { 0% { border-color: #e74c3c; } 50% { border-color: #c0392b; } 100% { border-color: #e74c3c; } }
    </style>
</head>
<body>

<div id="notification-popup">NACHRICHT</div>

<div id="setup-overlay" class="overlay">
    <div class="menu-box">
        <h1>Battle of the Gods</h1>
        <select id="player-count" onchange="updateDefaultSettings()">
            <option value="2">2 Spieler</option><option value="3">3 Spieler</option>
            <option value="4">4 Spieler</option><option value="5">5 Spieler</option>
            <option value="6">6 Spieler</option>
        </select>
        <div class="settings-grid">
            <label>Ziel Artefakte:</label><input type="number" id="cfg-target" value="7">
            <label>Ring 1 (Au√üen):</label><input type="number" id="cfg-ring1" value="3">
            <label>Ring 2 (Mitte):</label><input type="number" id="cfg-ring2" value="5">
            <label>Ring 3 (Innen):</label><input type="number" id="cfg-ring3" value="7">
        </div>
        <div class="button-row">
            <button class="menu-btn btn-start" onclick="loadStandardMap()">LOKAL SPIELEN</button>
            <button class="menu-btn btn-network" onclick="startNetworkMode()">ONLINE SPIELEN</button>
        </div>
        <div class="dev-credits">Dev: <span class="dev-name">Johannes K aka Maxc the Sox</span></div>
    </div>
</div>

<div id="lobby-overlay" class="overlay">
    <div class="menu-box" style="width: 450px;">
        <h2>ONLINE LOBBY</h2>
        <div id="lobby-join-area">
            <input type="text" id="room-input" placeholder="Raum Name (z.B. 'Arena')" style="padding: 15px; width: 80%; background: #222; border: 2px solid #d4af37; color: white; border-radius: 5px; font-size: 1.2em; text-align: center; margin-bottom: 20px;">
            <div class="button-row">
                <button class="menu-btn btn-start" onclick="createRoom()">ERSTELLEN</button>
                <button class="menu-btn btn-network" onclick="joinRoom()">BEITRETEN</button>
            </div>
        </div>
        <div id="lobby-wait-area" class="hidden">
            <p id="lobby-status" style="color: #f1c40f; font-weight: bold; margin-bottom: 10px;"></p>
            <ul id="lobby-player-list"></ul>
            <button id="btn-host-start" class="menu-btn btn-start hidden" onclick="requestStartGame()">SPIEL STARTEN</button>
            <p id="lobby-wait-msg" class="hidden" style="color:#aaa; font-style:italic;">Warte auf Host...</p>
        </div>
        <button class="btn btn-secondary" onclick="closeLobby()" style="margin-top: 20px; width: 50%;">Zur√ºck</button>
    </div>
</div>

<div id="ui-panel">
    <div id="player-turn-display" style="padding:10px; border:2px solid transparent; text-align:center; font-weight:bold;">Spieler X</div>
    <div id="guide-text" style="background:#d4af37; color:black; padding:8px; text-align:center; font-weight:bold; margin-bottom:10px;">BITTE WARTEN...</div>
    <div id="artifact-display" style="text-align:center; color:#f1c40f; font-weight:bold;">üèÜ Artefakte: 0 / ?</div>
    <div id="action-controls">
        <div id="choice-area">
            <button id="btn-choice-draw" class="btn" style="background:#50e3c2" onclick="handleChoice('DRAWING')">2x Karte ziehen</button>
            <button id="btn-choice-move" class="btn" style="background:#50e3c2" onclick="handleChoice('MOVING')">Bewegen</button>
        </div>
        <div id="drawing-area" class="hidden">
            <div id="draw-selection">
                <button class="btn" style="background:#50e3c2" onclick="prepareDraw('LANDSCAPE')">Landschaftskarte</button>
                <button class="btn" style="background:#50e3c2" onclick="prepareDraw('ACTION')">Aktionskarte</button>
                <p style="text-align:center; margin-top:5px;">Noch <span id="cards-left-display">2</span></p>
            </div>
            <div id="active-card" class="hidden">
                <div class="card-preview"><span id="card-icon" style="font-size: 2.5em; display: block;"></span><span id="card-name" style="font-weight: bold; text-transform: uppercase;"></span></div>
                <div id="dice-section" class="hidden"><div id="dice-display"><span id="dice-symbol">?</span></div><button id="btn-roll-dice" class="btn" style="background:#f1c40f" onclick="rollDice()">W√úRFELN</button></div>
                <p id="placement-info" style="color:#f1c40f; text-align:center; margin-top:5px; font-weight:bold;"></p>
                <div id="rotation-controls" class="hidden"><button class="btn" style="background:#50e3c2" onclick="rotateRiver()">Drehen ‚Üª</button><button class="btn" style="background:#2ecc71; color:white;" onclick="confirmRiver()">Setzen ‚úì</button></div>
            </div>
            <button id="btn-finish-drawing" class="btn hidden" style="background:#e74c3c; color:white;" onclick="cancelCurrentCard()">Ziehen beenden</button>
            <button id="btn-discard-new" class="btn hidden" style="background:#e74c3c; color:white;" onclick="discardNewCard()">Abwerfen</button>
        </div>
        <div id="movement-area" class="hidden">
            <p id="ap-display" style="text-align:center; font-weight:bold; color:#50e3c2; margin-bottom:5px;"></p>
            <button class="btn" style="background:#95a5a6; color:white;" onclick="deselectUnit()">Auswahl aufheben</button>
            <button class="btn" style="background:#e74c3c; color:white;" onclick="finishPath()">Zug beenden</button>
        </div>
    </div>
    <div id="hover-info" style="display: none; margin-top:10px;"><div id="hover-terrain" style="color: #fff; font-weight: bold;"></div><div id="hover-extra" style="color: #f1c40f; font-weight: bold;"></div></div>
</div>

<div id="inventory-panel"><div class="inv-header" style="color:#3498db; text-align:center; font-weight:bold; border-bottom:1px solid #444; padding-bottom:5px; margin-bottom:10px;">Inventar (Max 3)</div><div id="inv-slot-0" class="inv-slot" onclick="handleInventoryClick(0)"><span class="inv-icon"></span><span class="inv-name">Leer</span></div><div id="inv-slot-1" class="inv-slot" onclick="handleInventoryClick(1)"><span class="inv-icon"></span><span class="inv-name">Leer</span></div><div id="inv-slot-2" class="inv-slot" onclick="handleInventoryClick(2)"><span class="inv-icon"></span><span class="inv-name">Leer</span></div></div>
<div id="apo-panel"><div class="apo-header" style="color:#e74c3c; text-align:center; font-weight:bold; border-bottom:1px solid #444; padding-bottom:5px; margin-bottom:10px;">Apokalypse</div><div class="apo-row"><span>Ring 1</span> <span id="apo-1" style="color:#2ecc71">STABIL</span></div><div class="apo-row"><span>Ring 2</span> <span id="apo-2" style="color:#2ecc71">STABIL</span></div><div class="apo-row"><span>Ring 3</span> <span id="apo-3" style="color:#2ecc71">STABIL</span></div><div style="margin-top:10px; font-size:0.85em; color:#aaa; text-align:center;">N√§chster Kollaps bei <span id="apo-next-trigger" style="color:#fff; font-weight:bold;">3</span> Artefakten</div></div>
<div id="victory-panel"><h1 style="font-size:1.8em; border-bottom:1px solid #444;">SIEG!</h1><div id="winner-name" style="font-size:1.1em; color:#fff; margin-bottom:15px; font-weight:bold;">Spieler X</div><div id="victory-reason" style="font-size:0.9em; color:#aaa; margin-bottom:20px; font-style:italic;">...</div><button class="btn btn-start" onclick="location.reload()">NEUES SPIEL</button></div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); const hexDirections = [{q:1,r:0}, {q:0,r:1}, {q:-1,r:1}, {q:-1,r:0}, {q:0,r:-1}, {q:1,r:-1}]; const terrainColors = { water: '#4fa3e0', river: '#81ecec', desert: '#d4bb7e', swamp: '#3d4a3d', plains: '#5a8d46', forest: '#1b4d3e', mountains: '#4d4d4d', road: '#333333', hills: '#7f8c8d', tundra: '#b2bec3', void: '#000' }; const terrainNames = { water: 'Wasser', river: 'Fluss', desert: 'W√ºste', swamp: 'STARTBURG', plains: 'Ebene', forest: 'Wald', mountains: 'Gebirge', road: 'STRASSE', hills: 'H√ºgel', tundra: 'Tundra', void: 'VERNICHTET' };
let mapData = { hexes: {}, landmarks: [] }; let hexSize = 40, camera = { x: 0, y: 0, zoom: 0.8 }, iconCache = {}; let players = [], currentPlayerIdx = 0, gameState = "SETUP"; let drawPoints = 2, actionPoints = 2, collectedArtifacts = 0; let targetArtifacts = 7, ringThresholds = [3, 5, 7], closedRings = { outer: false, middle: false, inner: false }; let pathDrawn = false, pathMoved = false, isDragging = false, lastMouse = { x: 0, y: 0 }; let currentCard = null, diceValue = 0, placementsRemaining = 0, pendingRiverHex = null; let selectedUnit = null, riverEscapeHexes = [], pendingCardSlot = null, pushRemaining = 0, currentPushUnit = null, boatLandingTargets = []; let isGameOver = false;
let socket = null; let isMultiplayer = false; let myPlayerIndex = -1; let roomName = "";

function updateDefaultSettings() { const count = parseInt(document.getElementById('player-count').value); document.getElementById('cfg-target').value = (count == 2) ? 7 : (count <= 4 ? 8 : 9); const rings = (count == 2) ? [3, 5, 7] : (count <= 4 ? [4, 6, 8] : [5, 7, 9]); document.getElementById('cfg-ring1').value = rings[0]; document.getElementById('cfg-ring2').value = rings[1]; document.getElementById('cfg-ring3').value = rings[2]; }

// FIX: L√ÑDT KARTENDATEN JETZT VOM EIGENEN SERVER (/api/map), UM CORB/CORS FEHLER ZU VERMEIDEN
async function loadStandardMap() { 
    try { 
        // WICHTIG: Kein direkter fetch zu GitHub mehr!
        const response = await fetch('/api/map'); 
        if (!response.ok) throw new Error("Server antwortet nicht");
        const data = await response.json(); 
        let pCount = isMultiplayer ? players.length : parseInt(document.getElementById('player-count').value); 
        processLoadedMap(data, pCount); 
    } catch (e) { alert("Ladefehler: " + e.message); } 
}

function processLoadedMap(data, count) { mapData = data; Object.values(mapData.hexes).forEach(h => h.baseTerrain = h.terrain); mapData.landmarks.forEach(lm => { if(lm.icon && !iconCache[lm.icon]) { const img = new Image(); img.src = lm.icon; img.onload = () => render(); iconCache[lm.icon] = img; } }); if (!isMultiplayer) { players = Array.from({length: count}, (_, i) => ({ id: i+1, color: ["#ff4757", "#2e86de", "#2ecc71", "#f1c40f", "#9b59b6", "#e67e22"][i], units: [], inventory: [], skipped: false })); targetArtifacts = parseInt(document.getElementById('cfg-target').value); ringThresholds = [parseInt(document.getElementById('cfg-ring1').value), parseInt(document.getElementById('cfg-ring2').value), parseInt(document.getElementById('cfg-ring3').value)]; } document.getElementById('setup-overlay').style.display = 'none'; document.getElementById('lobby-overlay').style.display = 'none'; document.getElementById('ui-panel').style.display = 'block'; document.getElementById('apo-panel').style.display = 'block'; document.getElementById('inventory-panel').style.display = 'block'; canvas.width = window.innerWidth; canvas.height = window.innerHeight; gameState = "PLACING"; currentPlayerIdx = 0; centerMap(); updateUI(); render(); updateApoUI(); }
function centerMap() { const hexes = Object.values(mapData.hexes); if (hexes.length === 0) return; let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity; hexes.forEach(hex => { const x = hexSize * 1.5 * hex.q; const y = hexSize * Math.sqrt(3) * (hex.r + hex.q / 2); minX = Math.min(minX, x); maxX = Math.max(maxX, x); minY = Math.min(minY, y); maxY = Math.max(maxY, y); }); camera.x = canvas.width / 2 - ((minX + maxX) / 2) * camera.zoom; camera.y = canvas.height / 2 - ((minY + maxY) / 2) * camera.zoom; }
function getHexDistance(q1, r1, q2, r2) { return (Math.abs(q1 - q2) + Math.abs(q1 + r1 - q2 - r2) + Math.abs(r1 - r2)) / 2; }
canvas.addEventListener('wheel', e => { e.preventDefault(); const factor = Math.pow(1.1, -e.deltaY / 100); const wX = (e.clientX - camera.x) / camera.zoom, wY = (e.clientY - camera.y) / camera.zoom; camera.zoom = Math.min(Math.max(camera.zoom * factor, 0.2), 3); camera.x = e.clientX - wX * camera.zoom; camera.y = e.clientY - wY * camera.zoom; render(); }, { passive: false });
canvas.addEventListener('mousedown', e => { if (e.button === 0) { isDragging = true; lastMouse = { x: e.clientX, y: e.clientY }; } });
window.addEventListener('mouseup', () => isDragging = false);
window.addEventListener('mousemove', e => { if (isDragging) { camera.x += (e.clientX - lastMouse.x); camera.y += (e.clientY - lastMouse.y); lastMouse = { x: e.clientX, y: e.clientY }; render(); } const x = (e.clientX-camera.x)/(hexSize*camera.zoom), y = (e.clientY-camera.y)/(hexSize*camera.zoom), q = (2/3*x), r = (-1/3*x + Math.sqrt(3)/3*y); let rx = Math.round(q), rz = Math.round(r), ry = Math.round(-q-r); if (Math.abs(rx-q)>Math.abs(ry-(-q-r)) && Math.abs(rx-q)>Math.abs(rz-r)) rx = -ry-rz; else if (Math.abs(ry-(-q-r))>Math.abs(rz-r)) ry = -rx-rz; else rz = -rx-ry; const hex = mapData.hexes[`${rx},${rz}`], hInfo = document.getElementById('hover-info'); if (hex) { hInfo.style.display = 'block'; document.getElementById('hover-terrain').innerText = (terrainNames[hex.terrain] || hex.terrain).toUpperCase(); const lm = mapData.landmarks.find(l => l.q === rx && l.r === rz); let extraText = (lm && !lm.looted) ? "‚ôú RUINE MIT ARTEFAKT" : (lm ? "üï∏Ô∏è LEERE RUINE" : ""); if (lm && lm.icon && lm.icon.toLowerCase().includes('temple')) extraText = "‚ú® TEMPEL"; document.getElementById('hover-extra').innerText = extraText; } else hInfo.style.display = 'none'; });
canvas.addEventListener('click', e => { if (isGameOver || isDragging) return; const x = (e.clientX-camera.x)/(hexSize*camera.zoom), y = (e.clientY-camera.y)/(hexSize*camera.zoom), q = (2/3*x), r = (-1/3*x + Math.sqrt(3)/3*y); let rx = Math.round(q), rz = Math.round(r), ry = Math.round(-q-r); if (Math.abs(rx-q)>Math.abs(ry-(-q-r)) && Math.abs(rx-q)>Math.abs(rz-r)) rx = -ry-rz; else if (Math.abs(ry-(-q-r)) > Math.abs(rz-r)) ry = -rx-rz; else rz = -rx-ry; if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; socket.emit('sendAction', { room: roomName, actionType: 'CLICK_HEX', payload: { q: rx, r: rz } }); } else { executeGameLogic(rx, rz); } });

function executeGameLogic(rx, rz) {
    const hex = mapData.hexes[`${rx},${rz}`]; if (!hex || hex.terrain === 'void') return;
    if (gameState === "PLACING" && hex.terrain === 'swamp') { if (players.some(p => p.units.some(u => u.q === rx && u.r === rz))) return; players[currentPlayerIdx].units.push({ q: rx, r: rz }); if (players.reduce((sum, p) => sum + p.units.length, 0) === players.length * 2) { currentPlayerIdx = 0; startTurn(); } else { currentPlayerIdx = (currentPlayerIdx + 1) % players.length; } } 
    else if (gameState === "MOVING") { if (selectedUnit) { let dist = getHexDistance(selectedUnit.q, selectedUnit.r, rx, rz); if (dist === 1) { processMovement(selectedUnit, rx, rz); } else { const u = players[currentPlayerIdx].units.find(u => u.q === rx && u.r === rz); selectedUnit = u || null; } } else { const u = players[currentPlayerIdx].units.find(u => u.q === rx && u.r === rz); if (u) selectedUnit = u; } } 
    else if (gameState === "RIVER_ESCAPE") { if (riverEscapeHexes.some(p => p.q === rx && p.r === rz)) { selectedUnit.q = rx; selectedUnit.r = rz; checkLandmark(rx, rz); riverEscapeHexes = []; actionPoints = 0; executeFinishPath(); } } 
    else if (gameState === "BOAT_LANDING") { if (boatLandingTargets.some(t => t.q === rx && t.r === rz)) { const p = players[currentPlayerIdx]; if (hex.terrain === 'mountains') { const hookIdx = p.inventory.findIndex(c => c.type === 'tool_hook'); if (hookIdx === -1) { if(!isMultiplayer) alert("Kletterhaken ben√∂tigt!"); return; } p.inventory.splice(hookIdx, 1); } const boatIdx = p.inventory.findIndex(c => c.type === 'tool_boat'); if (boatIdx !== -1) p.inventory.splice(boatIdx, 1); selectedUnit.q = rx; selectedUnit.r = rz; checkLandmark(rx, rz); boatLandingTargets = []; actionPoints = 0; executeFinishPath(); } } 
    else if (gameState === "RIVER_ESCAPE_PUSH") { 
        if (riverEscapeHexes.some(p => p.q === rx && p.r === rz)) { 
            selectedUnit.q = rx; selectedUnit.r = rz; checkLandmark(rx, rz); riverEscapeHexes = []; 
            currentPushUnit = null; selectedUnit = null; 
            if (pushRemaining > 0) gameState = "SELECT_PUSH_TARGET_2"; 
            else { players[currentPlayerIdx].inventory.splice(pendingCardSlot, 1); gameState = "CHOOSING"; } 
        } 
    } 
    else if (gameState === "PLACING_TERRAIN" && currentCard) { if (['mountains', 'forest', 'river', 'road'].includes(hex.terrain)) return; hex.terrain = currentCard.type; if (currentCard.type === 'river') { hex.direction = 0; pendingRiverHex = hex; gameState = "ROTATING_RIVER"; } else { placementsRemaining--; if (placementsRemaining <= 0) finishCard(); } } 
    else if (gameState === "SELECT_SKIP") { const owner = players.find(p => p.id !== players[currentPlayerIdx].id && p.units.some(u => u.q === rx && u.r === rz)); if (owner) { owner.skipped = true; players[currentPlayerIdx].inventory.splice(pendingCardSlot, 1); gameState = "CHOOSING"; } } 
    else if (gameState === "SELECT_TELEPORT_UNIT") { const u = players[currentPlayerIdx].units.find(u => u.q === rx && u.r === rz); if (u) { selectedUnit = u; gameState = "SELECT_TELEPORT_TARGET"; } } 
    else if (gameState === "SELECT_TELEPORT_TARGET") { const lm = mapData.landmarks.find(l => l.q === rx && l.r === rz); if (lm && lm.looted) { selectedUnit.q = rx; selectedUnit.r = rz; players[currentPlayerIdx].inventory.splice(pendingCardSlot, 1); selectedUnit = null; gameState = "CHOOSING"; } } 
    else if (gameState === "SELECT_PUSH_TARGET_1" || gameState === "SELECT_PUSH_TARGET_2") { const u = players.find(p => p.id !== players[currentPlayerIdx].id && p.units.some(u => u.q === rx && u.r === rz))?.units.find(u => u.q === rx && u.r === rz); if (u) { currentPushUnit = u; gameState = "SELECT_PUSH_DESTINATION"; } } 
    else if (gameState === "SELECT_PUSH_DESTINATION") { 
        if (getHexDistance(currentPushUnit.q, currentPushUnit.r, rx, rz) === 1 && hex && !['mountains', 'void', 'water'].includes(hex.terrain)) { 
            currentPushUnit.q = rx; currentPushUnit.r = rz; 
            pushRemaining--; 
            if (!handlePushFlow(currentPushUnit)) { 
                if (pushRemaining > 0) { gameState = "SELECT_PUSH_TARGET_2"; currentPushUnit = null; } 
                else { players[currentPlayerIdx].inventory.splice(pendingCardSlot, 1); gameState = "CHOOSING"; currentPushUnit = null; } 
            }
        } 
    }
    updateUI(); render();
}

function processMovement(unit, tQ, tR) {
    const oldHex = mapData.hexes[`${unit.q},${unit.r}`]; const newHex = mapData.hexes[`${tQ},${tR}`]; if (!newHex || ['void', 'water'].includes(newHex.terrain)) return; const p = players[currentPlayerIdx];
    if (newHex.terrain === 'mountains') { const hookIndex = p.inventory.findIndex(c => c.type === 'tool_hook'); if (oldHex.terrain !== 'mountains') { if (hookIndex === -1) { if(!isMultiplayer) alert("Braucht Seil & Haken!"); return; } p.inventory.splice(hookIndex, 1); } }
    if (newHex.terrain === 'river') { const boatIndex = p.inventory.findIndex(c => c.type === 'tool_boat'); if (boatIndex !== -1) { selectedUnit = unit; let rivers = getConnectedRivers(tQ, tR); let shores = []; let seen = new Set(); rivers.forEach(r => { for(let d of hexDirections) { let sQ = r.q + d.q, sR = r.r + d.r; let sHex = mapData.hexes[`${sQ},${sR}`]; if(sHex && !['river', 'water', 'void'].includes(sHex.terrain) && !players.some(pl => pl.units.some(u => u.q === sQ && u.r === sR))) { let key = `${sQ},${sR}`; if(!seen.has(key)) { seen.add(key); shores.push(sHex); } } } }); boatLandingTargets = shores; if(boatLandingTargets.length > 0) { unit.q = tQ; unit.r = tR; gameState = "BOAT_LANDING"; updateUI(); render(); return; } } }
    let cost = (newHex.terrain === 'road' && oldHex.terrain !== 'road') ? 0 : 1;
    if (actionPoints < cost) { if(!isMultiplayer) alert("Keine Aktionspunkte!"); return; }
    unit.q = tQ; unit.r = tR; checkLandmark(tQ, tR);
    if (newHex.terrain === 'river') { let curH = newHex; let safety = 0; while (safety < 20) { safety++; let nQ = unit.q + hexDirections[curH.direction || 0].q; let nR = unit.r + hexDirections[curH.direction || 0].r; let nH = mapData.hexes[`${nQ},${nR}`]; const occupied = players.some(p => p.units.some(u => u.q === nQ && u.r === nR)); if (!nH || ['mountains', 'water', 'void'].includes(nH.terrain) || occupied) { riverEscapeHexes = hexDirections.map(d => ({q: unit.q+d.q, r: unit.r+d.r})).filter(p => { const h = mapData.hexes[`${p.q},${p.r}`]; return h && !['mountains', 'water', 'void', 'river'].includes(h.terrain); }); if (riverEscapeHexes.length > 0) { gameState = "RIVER_ESCAPE"; updateUI(); return; } else { actionPoints = 0; executeFinishPath(); return; } } else if (nH.terrain === 'river') { unit.q = nQ; unit.r = nR; checkLandmark(nQ, nR); curH = nH; } else { unit.q = nQ; unit.r = nR; checkLandmark(nQ, nR); actionPoints = 0; executeFinishPath(); return; } } } else { actionPoints -= cost; if (newHex.terrain === 'forest') actionPoints = 0; if (actionPoints <= 0) executeFinishPath(); }
    updateUI(); render();
}

function showNotification(text) { const popup = document.getElementById('notification-popup'); popup.innerText = text; popup.classList.add('show'); setTimeout(() => { popup.classList.remove('show'); }, 3000); }
function handleChoice(choice) { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; socket.emit('sendAction', { room: roomName, actionType: 'CHOICE', payload: choice }); } else { executeChoice(choice); } }
function executeChoice(choice) { if (choice === 'DRAWING') { drawPoints = 2; gameState = "DRAWING"; } else if (choice === 'MOVING') { gameState = "MOVING"; } updateUI(); render(); }
function prepareDraw(type) { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; let card; if (type === 'LANDSCAPE') { card = [{name:"Berg",type:"mountains",icon:"‚õ∞Ô∏è"},{name:"Wald",type:"forest",icon:"üå≤"},{name:"Fluss",type:"river",icon:"üåä"},{name:"Stra√üe",type:"road",icon:"üõ§Ô∏è"}][Math.floor(Math.random()*4)]; card.deck = "LANDSCAPE"; } else { const cards = [{name:"Extra Zug",type:"extra_move",icon:"üèÉ"},{name:"Aussetzen",type:"skip_turn",icon:"üö´"},{name:"Teleport",type:"teleport",icon:"‚ú®"},{name:"Gegner zur√ºckwerfen",type:"push_enemy",icon:"üí®"},{name:"Wirbelsturm",type:"tornado",icon:"üå™Ô∏è"},{name:"Seil & Haken",type:"tool_hook",icon:"ü™¢"},{name:"Schlauchboot",type:"tool_boat",icon:"üõ∂"}]; card = cards[Math.floor(Math.random()*cards.length)]; card.deck = "ACTION"; } socket.emit('sendAction', { room: roomName, actionType: 'PREPARE_DRAW', payload: { type: type, card: card } }); } else { let card; if (type === 'LANDSCAPE') { card = [{name:"Berg",type:"mountains",icon:"‚õ∞Ô∏è"},{name:"Wald",type:"forest",icon:"üå≤"},{name:"Fluss",type:"river",icon:"üåä"},{name:"Stra√üe",type:"road",icon:"üõ§Ô∏è"}][Math.floor(Math.random()*4)]; card.deck = "LANDSCAPE"; } else { const cards = [{name:"Extra Zug",type:"extra_move",icon:"üèÉ"},{name:"Aussetzen",type:"skip_turn",icon:"üö´"},{name:"Teleport",type:"teleport",icon:"‚ú®"},{name:"Gegner zur√ºckwerfen",type:"push_enemy",icon:"üí®"},{name:"Wirbelsturm",type:"tornado",icon:"üå™Ô∏è"},{name:"Seil & Haken",type:"tool_hook",icon:"ü™¢"},{name:"Schlauchboot",type:"tool_boat",icon:"üõ∂"}]; card = cards[Math.floor(Math.random()*cards.length)]; card.deck = "ACTION"; } executePrepareDraw(card); } }
function executePrepareDraw(card) { currentCard = card; if (currentCard.deck === 'ACTION') { if (currentCard.type === 'tornado') { executeTornado(); return; } gameState = "ACTION_VIEW"; } else { gameState = "DICE_ROLL"; } diceValue = 0; document.getElementById('dice-symbol').innerText = "?"; updateUI(); }
function rollDice() { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; const val = [3, 2, 2, 1, 1, 1][Math.floor(Math.random() * 6)]; socket.emit('sendAction', { room: roomName, actionType: 'ROLL_DICE', payload: val }); } else { executeRollDice([3, 2, 2, 1, 1, 1][Math.floor(Math.random() * 6)]); } }
function executeRollDice(val) { const diceDisplay = document.getElementById('dice-display'); diceDisplay.classList.add('rolling'); setTimeout(() => { diceValue = val; placementsRemaining = diceValue; document.getElementById('dice-symbol').innerText = ['','‚öÄ','‚öÅ','‚öÇ'][diceValue] || diceValue; diceDisplay.classList.remove('rolling'); gameState = "PLACING_TERRAIN"; updateUI(); }, 500); }
function rotateRiver() { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; socket.emit('sendAction', { room: roomName, actionType: 'ROTATE_RIVER' }); } else { executeRotateRiver(); } }
function executeRotateRiver() { if (pendingRiverHex) { pendingRiverHex.direction = (pendingRiverHex.direction + 1) % 6; render(); } }
function confirmRiver() { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; socket.emit('sendAction', { room: roomName, actionType: 'CONFIRM_RIVER' }); } else { executeConfirmRiver(); } }
function executeConfirmRiver() { if (!pendingRiverHex) return; let checkQ = pendingRiverHex.q, checkR = pendingRiverHex.r, safety = 0; while (safety < 50) { let cur = mapData.hexes[`${checkQ},${checkR}`]; if (!cur || cur.terrain !== 'river') break; checkQ += hexDirections[cur.direction || 0].q; checkR += hexDirections[cur.direction || 0].r; if (checkQ === pendingRiverHex.q && checkR === pendingRiverHex.r) { if(!isMultiplayer) alert("KREISLAUF ERKANNT!"); return; } safety++; } pendingRiverHex = null; placementsRemaining--; if (placementsRemaining <= 0) finishCard(); else gameState = "PLACING_TERRAIN"; updateUI(); render(); }
function cancelCurrentCard() { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; socket.emit('sendAction', { room: roomName, actionType: 'CANCEL_CARD' }); } else { executeCancelCard(); } }
function executeCancelCard() { if (drawPoints <= 0) { pathDrawn = true; currentCard = null; checkTurnEnd(); return; } drawPoints--; currentCard = null; pendingRiverHex = null; placementsRemaining = 0; gameState = (drawPoints > 0) ? "DRAWING" : "DRAWING_DONE"; updateUI(); render(); }
function discardNewCard() { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; socket.emit('sendAction', { room: roomName, actionType: 'DISCARD_CARD' }); } else { executeDiscardCard(); } }
function executeDiscardCard() { drawPoints--; currentCard = null; gameState = (drawPoints <= 0) ? "DRAWING_DONE" : "DRAWING"; updateUI(); render(); }
function finishPath() { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex) return; socket.emit('sendAction', { room: roomName, actionType: 'FINISH_PATH' }); } else { executeFinishPath(); } }
function executeFinishPath() { actionPoints = 0; pathMoved = true; selectedUnit = null; checkTurnEnd(); }
function deselectUnit() { selectedUnit = null; updateUI(); render(); }
function handleInventoryClick(slotIdx) { if (isMultiplayer) { if (currentPlayerIdx !== myPlayerIndex && gameState !== "SWAP_CARD") return; socket.emit('sendAction', { room: roomName, actionType: 'INVENTORY_CLICK', payload: slotIdx }); } else { executeInventoryClick(slotIdx); } }
function executeInventoryClick(slotIdx) { const p = players[currentPlayerIdx], card = p.inventory[slotIdx]; if (gameState === "SWAP_CARD") { p.inventory[slotIdx] = currentCard; executeDiscardCard(); return; } if (pendingCardSlot === slotIdx && gameState !== "CHOOSING" && gameState !== "MOVING") { pendingCardSlot = null; selectedUnit = null; currentPushUnit = null; pushRemaining = 0; gameState = "CHOOSING"; updateUI(); render(); return; } if (gameState === "CHOOSING" || gameState === "MOVING") { if (!card) return; if (card.type === 'tool_hook' || card.type === 'tool_boat') { if(!isMultiplayer) alert("Dies ist ein passives Werkzeug."); return; } if (card.type === 'extra_move') { p.inventory.splice(slotIdx, 1); actionPoints++; pathMoved = false; } else if (card.type === 'skip_turn') { gameState = "SELECT_SKIP"; pendingCardSlot = slotIdx; } else if (card.type === 'teleport') { gameState = "SELECT_TELEPORT_UNIT"; pendingCardSlot = slotIdx; } else if (card.type === 'push_enemy') { gameState = "SELECT_PUSH_TARGET_1"; pendingCardSlot = slotIdx; pushRemaining = 2; currentPushUnit = null; } updateUI(); } }
function finishCard() { if (currentCard && currentCard.deck === 'ACTION') { const p = players[currentPlayerIdx]; if (p.inventory.length < 3) { p.inventory.push(currentCard); drawPoints--; currentCard = null; gameState = (drawPoints <= 0) ? "DRAWING_DONE" : "DRAWING"; } else { gameState = "SWAP_CARD"; } } else { drawPoints--; currentCard = null; gameState = (drawPoints <= 0) ? "DRAWING_DONE" : "DRAWING"; } updateUI(); render(); }
function checkTurnEnd() { if (pathDrawn && pathMoved) { currentPlayerIdx = (currentPlayerIdx + 1) % players.length; startTurn(); } else { gameState = "CHOOSING"; updateUI(); render(); } }

function startTurn() { 
    if (players[currentPlayerIdx].skipped) { if(!isMultiplayer) alert(`Spieler ${players[currentPlayerIdx].id} muss aussetzen!`); players[currentPlayerIdx].skipped = false; currentPlayerIdx = (currentPlayerIdx + 1) % players.length; startTurn(); return; }
    pathDrawn = false; pathMoved = false; drawPoints = 2; actionPoints = 2; gameState = "CHOOSING"; 
    const activePlayer = players[currentPlayerIdx]; let msg = "";
    if (isMultiplayer) { msg = (currentPlayerIdx === myPlayerIndex) ? "‚öîÔ∏è DU BIST AM ZUG! ‚öîÔ∏è" : `‚è≥ SPIELER ${activePlayer.id} IST AM ZUG`; } else { msg = `‚öîÔ∏è SPIELER ${activePlayer.id} IST AM ZUG ‚öîÔ∏è`; }
    showNotification(msg); updateUI(); render(); 
}

function executeTornado() { const p = players[currentPlayerIdx]; let candidates = []; Object.values(mapData.hexes).forEach(h => { if (['water', 'void', 'mountains'].includes(h.terrain)) return; let isEdge = false; const dirs = [{q:1,r:0}, {q:0,r:1}, {q:-1,r:1}, {q:-1,r:0}, {q:0,r:-1}, {q:1,r:-1}]; for(let d of dirs) { let nQ = h.q + d.q, nR = h.r + d.r, nHex = mapData.hexes[`${nQ},${nR}`]; if (!nHex || ['water', 'void'].includes(nHex.terrain)) { isEdge = true; break; } } const occupied = players.some(pl => pl.units.some(u => u.q === h.q && u.r === h.r)); if (isEdge && !occupied) candidates.push(h); }); if (candidates.length === 0) { if(!isMultiplayer) alert("üå™Ô∏è Kein Rand verf√ºgbar!"); currentCard = null; pathDrawn = true; pathMoved = true; checkTurnEnd(); render(); return; } p.units.forEach(u => { let alreadyAtEdge = false; const dirs = [{q:1,r:0}, {q:0,r:1}, {q:-1,r:1}, {q:-1,r:0}, {q:0,r:-1}, {q:1,r:-1}]; for(let d of dirs) { let nQ = u.q + d.q, nR = u.r + d.r, nHex = mapData.hexes[`${nQ},${nR}`]; if (!nHex || ['water', 'void'].includes(nHex.terrain)) { alreadyAtEdge = true; break; } } if (!alreadyAtEdge) { let bestHex = null, minDist = Infinity; candidates.forEach(c => { let d = getHexDistance(u.q, u.r, c.q, c.r); if (d < minDist) { minDist = d; bestHex = c; } }); if (bestHex) { u.q = bestHex.q; u.r = bestHex.r; checkLandmark(u.q, u.r); candidates = candidates.filter(c => c !== bestHex); } } }); if(!isMultiplayer) alert("üå™Ô∏è WIRBELSTURM!"); currentCard = null; pathDrawn = true; pathMoved = true; checkTurnEnd(); render(); }
function updateApoUI() { const s1 = document.getElementById('apo-1'), s2 = document.getElementById('apo-2'), s3 = document.getElementById('apo-3'); s1.className = closedRings.outer ? "apo-status-dead" : (collectedArtifacts >= ringThresholds[0]-1 ? "apo-status-danger" : "apo-status-safe"); s1.innerText = closedRings.outer ? "ZERST√ñRT" : "STABIL"; s2.className = closedRings.middle ? "apo-status-dead" : (collectedArtifacts >= ringThresholds[1]-1 ? "apo-status-danger" : "apo-status-safe"); s2.innerText = closedRings.middle ? "ZERST√ñRT" : "STABIL"; s3.className = closedRings.inner ? "apo-status-dead" : (collectedArtifacts >= ringThresholds[2]-1 ? "apo-status-danger" : "apo-status-safe"); s3.innerText = closedRings.inner ? "ZERST√ñRT" : "STABIL"; let nextT = "KEINER"; if (!closedRings.outer) nextT = ringThresholds[0]; else if (!closedRings.middle) nextT = ringThresholds[1]; else if (!closedRings.inner) nextT = ringThresholds[2]; document.getElementById('apo-next-trigger').innerText = nextT; }
function triggerKollaps(baseTerrains, key) { closedRings[key] = true; Object.values(mapData.hexes).forEach(hex => { if (baseTerrains.includes(hex.baseTerrain) && hex.baseTerrain !== 'water' && hex.baseTerrain !== 'tundra') { hex.terrain = 'void'; players.forEach(p => p.units = p.units.filter(u => !(u.q === hex.q && u.r === hex.r))); } }); render(); updateApoUI(); const activePlayers = players.filter(p => p.units.length > 0); if (activePlayers.length === 1 && players.length > 1) { triggerVictory(activePlayers[0], "Einziger √úberlebender!"); } }
function checkApocalypse() { if (collectedArtifacts >= ringThresholds[0] && !closedRings.outer) triggerKollaps(['desert', 'swamp'], 'outer'); if (collectedArtifacts >= ringThresholds[1] && !closedRings.middle) triggerKollaps(['plains'], 'middle'); if (collectedArtifacts >= ringThresholds[2] && !closedRings.inner) triggerKollaps(['hills'], 'inner'); }
function triggerVictory(player, reason = "Tempel erreicht!") { isGameOver = true; camera.zoom = 0.5; centerMap(); render(); document.getElementById('ui-panel').classList.add('hidden'); document.getElementById('inventory-panel').classList.add('hidden'); document.getElementById('victory-panel').classList.remove('hidden'); document.getElementById('winner-name').innerText = `Spieler ${player.id} hat gewonnen!`; document.getElementById('winner-name').style.color = player.color; document.getElementById('victory-reason').innerText = reason; }
function checkLandmark(q, r) { const landmark = mapData.landmarks.find(l => l.q === q && l.r === r); if (!landmark) return; if (landmark.icon && landmark.icon.toLowerCase().includes('temple')) { if (collectedArtifacts >= targetArtifacts) triggerVictory(players[currentPlayerIdx]); } else if (!landmark.looted) { landmark.looted = true; collectedArtifacts++; checkApocalypse(); updateUI(); updateApoUI(); } }
function getConnectedRivers(startQ, startR) { let visited = new Set(); let queue = [{q: startQ, r: startR}]; let riverGroup = []; while(queue.length > 0) { let curr = queue.shift(); let key = `${curr.q},${curr.r}`; if(visited.has(key)) continue; visited.add(key); riverGroup.push(curr); for(let d of hexDirections) { let nQ = curr.q + d.q, nR = curr.r + d.r; let nHex = mapData.hexes[`${nQ},${nR}`]; if(nHex && nHex.terrain === 'river' && !visited.has(`${nQ},${nR}`)) queue.push({q: nQ, r: nR}); } } return riverGroup; }
// FIX FLUSS LOGIK
function handlePushFlow(unit) { let curHex = mapData.hexes[`${unit.q},${unit.r}`]; while (curHex && curHex.terrain === 'river') { let nQ = unit.q + hexDirections[curHex.direction || 0].q, nR = unit.r + hexDirections[curHex.direction || 0].r, nH = mapData.hexes[`${nQ},${nR}`]; const occupied = players.some(p => p.units.some(u => u.q === nQ && u.r === nR)); if (nH && !['mountains', 'water', 'void'].includes(nH.terrain) && !occupied) { unit.q = nQ; unit.r = nR; checkLandmark(nQ, nR); curHex = nH; } else if (nH) { riverEscapeHexes = hexDirections.map(d => ({q: unit.q+d.q, r: unit.r+d.r})).filter(p => { const h = mapData.hexes[`${p.q},${p.r}`]; return h && !['mountains', 'water', 'void', 'river'].includes(h.terrain); }); if (riverEscapeHexes.length > 0) { selectedUnit = unit; gameState = "RIVER_ESCAPE_PUSH"; return true; } else break; } else break; } return false; }

canvas.width = window.innerWidth; canvas.height = window.innerHeight; updateDefaultSettings();
</script>
</body>
</html>